name: Release

on:
  push:
    tags:
      - 'v*'

concurrency:
  group: release
  cancel-in-progress: false

permissions:
  contents: write
  id-token: write
  pull-requests: read

jobs:
  verify-tag:
    name: Verify Tag
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.meta.outputs.version }}
      is_preview: ${{ steps.meta.outputs.is_preview }}
      release_message: ${{ steps.meta.outputs.release_message }}
      release_notes: ${{ steps.meta.outputs.release_notes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Verify tag signature via GitHub API
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME="${GITHUB_REF_NAME}"
          TAG_SHA=$(gh api "repos/${{ github.repository }}/git/ref/tags/${TAG_NAME}" --jq '.object.sha')

          # Dereference if it's an annotated tag (points to a tag object, not a commit)
          TAG_TYPE=$(gh api "repos/${{ github.repository }}/git/tags/${TAG_SHA}" --jq '.object.type' 2>/dev/null || echo "commit")
          if [ "$TAG_TYPE" = "commit" ]; then
            VERIFIED=$(gh api "repos/${{ github.repository }}/git/tags/${TAG_SHA}" --jq '.verification.verified')
          else
            VERIFIED=$(gh api "repos/${{ github.repository }}/git/tags/${TAG_SHA}" --jq '.verification.verified')
          fi

          if [ "$VERIFIED" != "true" ]; then
            echo "::error::Tag ${TAG_NAME} is not signed or signature verification failed"
            exit 1
          fi
          echo "Tag ${TAG_NAME} signature verified"

      - name: Extract version and release notes
        id: meta
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"

          # Detect preview (rc) tags: v1.0.0rc â†’ is_preview=true
          if [[ "$VERSION" == *rc ]]; then
            echo "is_preview=true" >> "$GITHUB_OUTPUT"
            echo "Preview release detected: ${VERSION}"
          else
            echo "is_preview=false" >> "$GITHUB_OUTPUT"
          fi

          # Verify tag version matches package.json (skip for preview tags
          # since the rc suffix won't match the package version)
          if [[ "$VERSION" != *rc ]]; then
            PKG_VERSION=$(node -p "require('./package.json').version")
            if [ "$VERSION" != "$PKG_VERSION" ]; then
              echo "::error::Tag version (${VERSION}) does not match package.json (${PKG_VERSION})"
              exit 1
            fi
          fi

          # Find the merge commit the tag points to, then find its PR
          COMMIT_SHA=$(git rev-list -n 1 "${GITHUB_REF_NAME}")
          PR_NUMBER=$(gh api "repos/${{ github.repository }}/commits/${COMMIT_SHA}/pulls" --jq '.[0].number // empty')

          # Tag subject as fallback for release message
          TAG_SUBJECT=$(git tag -l --format='%(subject)' "${GITHUB_REF_NAME}")

          if [ -z "$PR_NUMBER" ]; then
            echo "::warning::No PR found for tagged commit â€” release notes will be empty"
            RELEASE_MESSAGE="$TAG_SUBJECT"
            RELEASE_NOTES=""
          else
            PR_BODY=$(gh api "repos/${{ github.repository }}/pulls/${PR_NUMBER}" --jq '.body // ""')

            # Release message: extract from PR body "Release: ..." line, fall back to tag subject
            PR_FIRST_LINE=$(echo "$PR_BODY" | head -1)
            if echo "$PR_FIRST_LINE" | grep -q '^Release: '; then
              RELEASE_MESSAGE=$(echo "$PR_FIRST_LINE" | sed 's/^Release: //')
            else
              RELEASE_MESSAGE="$TAG_SUBJECT"
            fi

            # Release notes: strip release title line, test plan, and metadata
            RELEASE_NOTES=$(echo "$PR_BODY" \
              | sed '1{/^Release: /d}' \
              | sed '/./,$!d' \
              | sed '/^## Test [Pp]lan/,$d' \
              | sed '/Co-[Aa]uthored-[Bb]y:/d' \
              | sed '/Generated with \[Claude Code\]/d' \
              | sed '/^ðŸ¤–/d' \
              | sed -e :a -e '/^[[:space:]]*$/{ $d; N; ba; }' \
            )
          fi

          echo "release_message=${RELEASE_MESSAGE}" >> "$GITHUB_OUTPUT"

          {
            echo "release_notes<<RELEASE_NOTES_EOF"
            echo "$RELEASE_NOTES"
            echo "RELEASE_NOTES_EOF"
          } >> "$GITHUB_OUTPUT"

  build-macos:
    name: Build macOS (${{ matrix.arch }})
    needs: verify-tag
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: arm64
            runner: macos-latest
          - arch: x64
            runner: macos-latest
    outputs:
      sha256_arm64: ${{ steps.hash.outputs.sha256_arm64 }}
      size_arm64: ${{ steps.hash.outputs.size_arm64 }}
      sha256_x64: ${{ steps.hash.outputs.sha256_x64 }}
      size_x64: ${{ steps.hash.outputs.size_x64 }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Import signing certificate
        env:
          APPLE_CERTIFICATE_P12: ${{ secrets.APPLE_CERTIFICATE_P12 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          CERT_PATH="$RUNNER_TEMP/cert.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain"
          echo "$APPLE_CERTIFICATE_P12" | base64 --decode > "$CERT_PATH"

          security create-keychain -p "" "$KEYCHAIN_PATH"
          security set-keychain-settings "$KEYCHAIN_PATH"
          security unlock-keychain -p "" "$KEYCHAIN_PATH"
          security import "$CERT_PATH" -k "$KEYCHAIN_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple: -s -k "" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')

          # Extract the signing identity name from the imported cert
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID Application" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          echo "APPLE_SIGNING_IDENTITY=${IDENTITY}" >> "$GITHUB_ENV"
          echo "Signing identity: ${IDENTITY}"

      - name: Build, sign, and notarize
        env:
          APPLE_SIGNING_IDENTITY: ${{ env.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          npx electron-forge make --arch=${{ matrix.arch }}

      - name: Compute artifact hashes
        id: hash
        run: |
          VERSION="${{ needs.verify-tag.outputs.version }}"
          ARCH="${{ matrix.arch }}"

          # Find the ZIP (for auto-updater)
          ZIP_PATH=$(find out/make -name "*.zip" -type f | head -1)
          SHA256=$(shasum -a 256 "$ZIP_PATH" | awk '{print $1}')
          SIZE=$(stat -f%z "$ZIP_PATH")

          echo "sha256_${ARCH}=${SHA256}" >> "$GITHUB_OUTPUT"
          echo "size_${ARCH}=${SIZE}" >> "$GITHUB_OUTPUT"

      - name: Rename artifacts for upload
        run: |
          VERSION="${{ needs.verify-tag.outputs.version }}"
          ARCH="${{ matrix.arch }}"
          mkdir -p dist

          # Find and rename ZIP
          ZIP_PATH=$(find out/make -name "*.zip" -type f | head -1)
          cp "$ZIP_PATH" "dist/Clubhouse-${VERSION}-darwin-${ARCH}.zip"

          # Find and rename DMG
          DMG_PATH=$(find out/make -name "*.dmg" -type f | head -1)
          cp "$DMG_PATH" "dist/Clubhouse-${VERSION}-darwin-${ARCH}.dmg"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-darwin-${{ matrix.arch }}
          path: dist/
          retention-days: 5

  build-windows:
    name: Build Windows (${{ matrix.arch }})
    needs: verify-tag
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
          - arch: arm64
    outputs:
      sha256_win_x64: ${{ steps.hash.outputs.sha256_win_x64 }}
      size_win_x64: ${{ steps.hash.outputs.size_win_x64 }}
      sha256_win_arm64: ${{ steps.hash.outputs.sha256_win_arm64 }}
      size_win_arm64: ${{ steps.hash.outputs.size_win_arm64 }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Build Windows installer
        run: npx electron-forge make --arch=${{ matrix.arch }}

      - name: Compute artifact hashes
        id: hash
        shell: pwsh
        run: |
          $version = "${{ needs.verify-tag.outputs.version }}"
          $arch = "${{ matrix.arch }}"

          # Find the Setup exe (Squirrel output)
          $exe = Get-ChildItem -Path out/make -Recurse -Filter "*Setup*.exe" | Select-Object -First 1
          if (-not $exe) {
            Write-Error "No Setup exe found in out/make"
            exit 1
          }
          Write-Host "Found installer: $($exe.FullName)"

          $hash = (Get-FileHash -Path $exe.FullName -Algorithm SHA256).Hash.ToLower()
          $size = $exe.Length

          echo "sha256_win_${arch}=$hash" >> $env:GITHUB_OUTPUT
          echo "size_win_${arch}=$size" >> $env:GITHUB_OUTPUT

      - name: Rename artifacts for upload
        shell: pwsh
        run: |
          $version = "${{ needs.verify-tag.outputs.version }}"
          $arch = "${{ matrix.arch }}"
          New-Item -ItemType Directory -Force -Path dist | Out-Null

          # Find and rename Setup exe
          $exe = Get-ChildItem -Path out/make -Recurse -Filter "*Setup*.exe" | Select-Object -First 1
          Copy-Item $exe.FullName "dist/Clubhouse-${version}-win32-${arch}-Setup.exe"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-win32-${{ matrix.arch }}
          path: dist/
          retention-days: 5

  publish:
    name: Publish
    needs: [verify-tag, build-macos, build-windows]
    runs-on: ubuntu-latest
    environment: release
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true

      - name: Generate update manifest
        run: |
          VERSION="${{ needs.verify-tag.outputs.version }}"
          IS_PREVIEW="${{ needs.verify-tag.outputs.is_preview }}"
          MESSAGE=$(cat <<'MESSAGE_EOF'
          ${{ needs.verify-tag.outputs.release_message }}
          MESSAGE_EOF
          )
          NOTES=$(cat <<'NOTES_EOF'
          ${{ needs.verify-tag.outputs.release_notes }}
          NOTES_EOF
          )
          BASE_URL="https://stclubhousereleases.blob.core.windows.net/releases/artifacts"

          # Write to preview.json for rc tags, latest.json for stable
          if [ "$IS_PREVIEW" = "true" ]; then
            MANIFEST_NAME="preview.json"
          else
            MANIFEST_NAME="latest.json"
          fi

          jq -n \
            --arg version "$VERSION" \
            --arg date "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --arg message "$MESSAGE" \
            --arg notes "$NOTES" \
            --arg min_version "0.1.0" \
            --arg url_arm64 "${BASE_URL}/Clubhouse-${VERSION}-darwin-arm64.zip" \
            --arg sha256_arm64 "${{ needs.build-macos.outputs.sha256_arm64 }}" \
            --argjson size_arm64 ${{ needs.build-macos.outputs.size_arm64 }} \
            --arg url_x64 "${BASE_URL}/Clubhouse-${VERSION}-darwin-x64.zip" \
            --arg sha256_x64 "${{ needs.build-macos.outputs.sha256_x64 }}" \
            --argjson size_x64 ${{ needs.build-macos.outputs.size_x64 }} \
            --arg url_win_x64 "${BASE_URL}/Clubhouse-${VERSION}-win32-x64-Setup.exe" \
            --arg sha256_win_x64 "${{ needs.build-windows.outputs.sha256_win_x64 }}" \
            --argjson size_win_x64 ${{ needs.build-windows.outputs.size_win_x64 }} \
            --arg url_win_arm64 "${BASE_URL}/Clubhouse-${VERSION}-win32-arm64-Setup.exe" \
            --arg sha256_win_arm64 "${{ needs.build-windows.outputs.sha256_win_arm64 }}" \
            --argjson size_win_arm64 ${{ needs.build-windows.outputs.size_win_arm64 }} \
            '{
              version: $version,
              releaseDate: $date,
              releaseMessage: $message,
              releaseNotes: $notes,
              minVersion: $min_version,
              artifacts: {
                "darwin-arm64": {
                  url: $url_arm64,
                  sha256: $sha256_arm64,
                  size: $size_arm64
                },
                "darwin-x64": {
                  url: $url_x64,
                  sha256: $sha256_x64,
                  size: $size_x64
                },
                "win32-x64": {
                  url: $url_win_x64,
                  sha256: $sha256_win_x64,
                  size: $size_win_x64
                },
                "win32-arm64": {
                  url: $url_win_arm64,
                  sha256: $sha256_win_arm64,
                  size: $size_win_arm64
                }
              }
            }' > "artifacts/${MANIFEST_NAME}"

          echo "Generated ${MANIFEST_NAME}:"
          cat "artifacts/${MANIFEST_NAME}"

      - name: Authenticate to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Update history.json
        if: needs.verify-tag.outputs.is_preview != 'true'
        run: |
          VERSION="${{ needs.verify-tag.outputs.version }}"
          ACCOUNT="stclubhousereleases"
          CONTAINER="releases"
          MESSAGE=$(cat <<'MESSAGE_EOF'
          ${{ needs.verify-tag.outputs.release_message }}
          MESSAGE_EOF
          )
          NOTES=$(cat <<'NOTES_EOF'
          ${{ needs.verify-tag.outputs.release_notes }}
          NOTES_EOF
          )

          # Download existing history.json (or start with empty array)
          az storage blob download \
            --account-name "$ACCOUNT" \
            --container-name "$CONTAINER" \
            --name "updates/history.json" \
            --file history-existing.json \
            --auth-mode login 2>/dev/null || echo '[]' > history-existing.json

          # Validate existing history is valid JSON array
          if ! jq -e 'type == "array"' history-existing.json > /dev/null 2>&1; then
            echo "::warning::Existing history.json is not a valid array, starting fresh"
            echo '[]' > history-existing.json
          fi

          # Create the new entry
          jq -n \
            --arg version "$VERSION" \
            --arg date "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --arg message "$MESSAGE" \
            --arg notes "$NOTES" \
            '{
              version: $version,
              releaseDate: $date,
              releaseMessage: $message,
              releaseNotes: $notes
            }' > new-entry.json

          # Prepend new entry to history array
          jq --slurpfile entry new-entry.json '. = [$entry[0]] + .' history-existing.json > artifacts/history.json

          echo "Updated history.json ($(jq length artifacts/history.json) entries):"
          jq '.[0]' artifacts/history.json

      - name: Upload to Azure Blob Storage
        run: |
          VERSION="${{ needs.verify-tag.outputs.version }}"
          IS_PREVIEW="${{ needs.verify-tag.outputs.is_preview }}"
          ACCOUNT="stclubhousereleases"
          CONTAINER="releases"

          # Upload versioned artifacts (immutable)
          for file in artifacts/Clubhouse-*.zip artifacts/Clubhouse-*.dmg artifacts/Clubhouse-*.exe; do
            [ -f "$file" ] || continue
            BLOB_NAME="artifacts/$(basename "$file")"
            az storage blob upload \
              --account-name "$ACCOUNT" \
              --container-name "$CONTAINER" \
              --name "$BLOB_NAME" \
              --file "$file" \
              --overwrite false \
              --auth-mode login
          done

          if [ "$IS_PREVIEW" = "true" ]; then
            # Preview release: upload preview.json manifest
            az storage blob upload \
              --account-name "$ACCOUNT" \
              --container-name "$CONTAINER" \
              --name "updates/preview.json" \
              --file artifacts/preview.json \
              --overwrite \
              --content-type "application/json" \
              --auth-mode login

            # Copy installers to the preview/ slot (constantly overwritten)
            SLOT="preview"
          else
            # Stable release: upload latest.json and history.json
            az storage blob upload \
              --account-name "$ACCOUNT" \
              --container-name "$CONTAINER" \
              --name "updates/latest.json" \
              --file artifacts/latest.json \
              --overwrite \
              --content-type "application/json" \
              --auth-mode login

            az storage blob upload \
              --account-name "$ACCOUNT" \
              --container-name "$CONTAINER" \
              --name "updates/history.json" \
              --file artifacts/history.json \
              --overwrite \
              --content-type "application/json" \
              --auth-mode login

            SLOT="latest"
          fi

          # Copy DMGs to the appropriate slot (latest/ or preview/)
          for ARCH in arm64 x64; do
            az storage blob copy start \
              --account-name "$ACCOUNT" \
              --destination-container "$CONTAINER" \
              --destination-blob "${SLOT}/Clubhouse-${SLOT}-darwin-${ARCH}.dmg" \
              --source-uri "https://${ACCOUNT}.blob.core.windows.net/${CONTAINER}/artifacts/Clubhouse-${VERSION}-darwin-${ARCH}.dmg" \
              --auth-mode login
          done

          # Copy Windows installers to the appropriate slot
          for WIN_ARCH in x64 arm64; do
            az storage blob copy start \
              --account-name "$ACCOUNT" \
              --destination-container "$CONTAINER" \
              --destination-blob "${SLOT}/Clubhouse-${SLOT}-win32-${WIN_ARCH}-Setup.exe" \
              --source-uri "https://${ACCOUNT}.blob.core.windows.net/${CONTAINER}/artifacts/Clubhouse-${VERSION}-win32-${WIN_ARCH}-Setup.exe" \
              --auth-mode login
          done

          # Wait for copies to complete
          SLOT_BLOBS=(
            "${SLOT}/Clubhouse-${SLOT}-darwin-arm64.dmg"
            "${SLOT}/Clubhouse-${SLOT}-darwin-x64.dmg"
            "${SLOT}/Clubhouse-${SLOT}-win32-x64-Setup.exe"
            "${SLOT}/Clubhouse-${SLOT}-win32-arm64-Setup.exe"
          )
          for BLOB in "${SLOT_BLOBS[@]}"; do
            while true; do
              STATUS=$(az storage blob show \
                --account-name "$ACCOUNT" \
                --container-name "$CONTAINER" \
                --name "$BLOB" \
                --query "properties.copy.status" \
                --output tsv \
                --auth-mode login)
              if [ "$STATUS" = "success" ]; then
                echo "Copy complete: $BLOB"
                break
              elif [ "$STATUS" = "failed" ] || [ "$STATUS" = "aborted" ]; then
                echo "::error::Blob copy failed for $BLOB"
                exit 1
              fi
              sleep 2
            done
          done

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.verify-tag.outputs.version }}"
          IS_PREVIEW="${{ needs.verify-tag.outputs.is_preview }}"

          RELEASE_TITLE="v${VERSION} â€” ${{ needs.verify-tag.outputs.release_message }}"
          RELEASE_BODY=$(cat <<'BODY_EOF'
          ${{ needs.verify-tag.outputs.release_notes }}
          BODY_EOF
          )

          PRERELEASE_FLAG=""
          MANIFEST_FILE="artifacts/latest.json"
          if [ "$IS_PREVIEW" = "true" ]; then
            PRERELEASE_FLAG="--prerelease"
            MANIFEST_FILE="artifacts/preview.json"
          fi

          gh release create "v${VERSION}" \
            --repo "${{ github.repository }}" \
            --title "${RELEASE_TITLE}" \
            --notes "${RELEASE_BODY}" \
            $PRERELEASE_FLAG \
            artifacts/Clubhouse-*.zip \
            artifacts/Clubhouse-*.dmg \
            artifacts/Clubhouse-*.exe \
            "${MANIFEST_FILE}"
